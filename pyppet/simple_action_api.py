# Simple Action API with binary data packing
# Copyright Brett Hartshorn 2012-2013
# License: "New" BSD

import bpy
import struct
import collections
import inspect
import ctypes

## the API is generated by introspection of _API below ##
API = {} # function byte id : {'callback':func, 'arguments':[], 'struct-format':''}


def new_action( code, args, player=None ):
	callback = API[code]['callback']
	kwargs = _decode_args( code, args )
	return Action( callback, kwargs )


class Action(object):
	def __init__(self, callback, **kw):
		self._callback = callback
		self._kwargs = kw

	def do(self):
		self._callback( **self._kwargs )


###################################################

def _decode_args( code, data ):
	fmt = API[ code ]['struct-format']
	args = struct.unpack( fmt, data )
	kw = {}
	for name in API[ code ]['arguments']:
		kw[ name ] = API[ name ]
	return kw

class BlenderProxy(object): pass
_ctypes_to_struct_format = {
	BlenderProxy    :'I', # object id's are 32bit unsigned int
	ctypes.c_uint32 :'I',
	ctypes.c_int32  :'i',
	ctypes.c_uint16 :'H',
	ctypes.c_int16  :'h',
	ctypes.c_float  : 'f',
}

def _introspect( func ):
	a = {
		'callback':func, 
		'arguments':[], 
		'struct-format':'<', # always little endian?
		'arg-types':{},
	}
	spec = inspect.getargspec( func )
	for arg_name, arg_hint in zip(spec.args, spec.defaults):
		a['arguments'].append( arg_name )
		a['struct-format'] += _ctypes_to_struct_format[ arg_hint ]
		a['arg-types'][arg_name] = arg_hint

	return a


def _generate_api( api ):
	for i,name in enumerate( api ):
		byte_code = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[ i ]
		func = api[name]
		API[ byte_code ] = _introspect( func )

def size_of(a):
	if a is BlenderProxy: return  4 # 32bit uint
	else: return ctypes.sizeof(a)

_ctype_to_js_buffer_type = {
	BlenderProxy: 'Uint32Array',
	ctypes.c_float: 'Float32Array',
	ctypes.c_int32: 'Int32Array',
	ctypes.c_uint32: 'Uint32Array',
	ctypes.c_int16: 'Int16Array',
	ctypes.c_uint16: 'Uint16Array',
}

def generate_javascript():
	'''
	Genereate javascript functions that send binary data on the websocket.
	The server needs to call this and insert it into the javascript sent
	to the client.
	'''
	r = []
	for code in API:
		a = API[code]['arguments']
		r.append( 'function _callback_%s( %s )'%(code,','.join(a)) )
		r.append( '{')
		r.append( 'var x = [];')
		for i,arg_name in enumerate(a): ## TODO optimize packing
			ctype = API[code]['arg-types'][arg_name]
			size = size_of( ctype )
			r.append( 'var buffer = new ArrayBuffer(%s);'%size )
			r.append( 'var bytesView = new Uint8Array(buffer);' )
			r.append( 'x.push( bytesView );')
			r.append( 'var view = new %s(buffer)' %_ctype_to_js_buffer_type[ctype] )
			r.append( 'view[ %s ] = %s;'%(i,arg_name) )


		r.append( 'var arr = [];')
		for i,arg_name in enumerate(a): r.append( 'Array.apply(arr, buffers[%s]);'%i )
		r.append('ws.send( arr ); // send packed data to server')
		r.append( '}')

	s = '\n'.join(r)
	print('_'*80)
	print(s)
	print('_'*80)
	return s

#################################### callbacks #################################


def select_callback( uid=BlenderProxy ):
	assert uid is not BlenderProxy ## this is just used for the introspection kwargs hack

	#elif len(frame)==4:  moved to simple_action_api.py
	#	print(frame)
	#	uid = struct.unpack('<I', frame)[0]
	uid = _unpack()
	for ob in bpy.context.scene.objects: ob.select=False
	ob = get_object_by_UID( uid ) # TODO XXXXXXXXXXXX
	ob.select = True
	bpy.context.scene.objects.active = ob




_api = {
	'select': select_callback,

}
_generate_api( _api )







